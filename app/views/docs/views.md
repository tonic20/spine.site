<% title 'Представления и шаблонизация' %>

Согласно принятой в Spine терминологии, представления - это просто фрагменты HTML которые создают интерфейс вашего приложения. Spine не содержит каких-либо сложных виджетов для построения интерфейсов и не предписывает вам использовать какую-либо структуру представлений.

Чтобы быть уверенными, что интерфейс вашего приложения полностью асинхронный и подстраивается под устройство отображающее его (монитор компьютера, мобильный телефон и т.д.), вам следует выполнять рендеринг всех представлений вашего приложения на стороне клиента. Это означает, что вместо использования ERB (или других шаблонизаторов) в Ruby, или форматирования строк в Python, вам следует использовать шаблоны JavaScript, которые рендерятся на клиенте.

Существует несколько отличных решений для рендеринга на стороне клиента, например [Mustache](http://mustache.github.com) и [jQuery.tmpl](http://api.jquery.com/category/plugins/templates). В наших примерах мы будем использовать библиотеку называемую [Eco](https://github.com/sstephenson/eco).

Если вы создаете ваше приложения на JavaScript, а не на CoffeeScript, то я рекомендую вам взглянуть на [руководство по jQuery.tmpl](<%= docs_path("views_tmpl") %>) вместо чтения этой статьи.

##Шаблоны Eco

Шаблоны JavaScript очень похожи на шаблоны, что используются на стороне сервера. У вас в распоряжении находятся специальные теги шаблонов, которые взаимодействуют с HTML. Во время рендеринга эти теги выполняются и заменяются на HTML код. Отличная особенность шаблонов [Eco](https://github.com/sstephenson/eco) - это то, что они написаны на CoffeeScript, языке, с которым вы должно быть хорошо знакомы если используете Spine.

Вот пример шаблона с тегами Eco:

    <%% if @projects.length: %>
      <%% for project in @projects: %>
        <a href="<%%= project.url %>"><%%= project.name %></a>
        <p><%%= project.description %></p>
      <%% end %>
    <%% else: %>
      No projects
    <%% end %>

Как видите, синтаксис шаблонов удивительно прост. Просто используйте `<%%` теги для выполнения выражений на CoffeeScript и `<%%=` теги для печати возвращаемого значения. Ниже приведен полный список тегов шаблонов:
    
* `<%% expression %>`  
  Выполняет выражение CoffeeScript без его печати.

* `<%%= expression %>`  
  Выполняет выражение CoffeeScript и печатает результат его выполнения, `<` и `>` заменяются соответственно на `&lt;` и `&gt;` (выполняется экранизация тегов).

* `<%%- expression %>`  
  Выполняет выражение CoffeeScript и печатает его результат без экранизации тегов.

* `<%%= @property %>`  
  Экранизирует и печатает значение определенного свойства из контекста объекта, который передан для рендеринга шаблона.

* `<%%= @helper() %>`  
  Вызывает метод helper из контекста переданного в шаблон объекта и печатает результат его выполнения предварительно экранировав теги.

* `<%% @helper -> %>...<%% end %>`  
  Вызывает метод helper, который первым аргументом принимает функцию. Функция захватывает содержимое тега (...) и выводит его по выполнении.
  
Рендеринг шаблонов выполняется в определенном контексте, например в контексте экземпляра модели. В CoffeeScript символ `@` является альтернативой для `this` в JavaScript и ссылается на контекст. 

##Компиляция шаблонов

Eco позволяет вам рендерить шаблоны динамически, прямо в браузере, или выполнять их предварительную компиляцию используя Node. Лично мне больше нравится второй вариант, поскольку он ускоряет работу рендеринга шаблонов за счет того, что устраняется одна из стадий рендеринга и пользователь быстрее получает готовую HTML страницу.

[Hem](<%= docs_path("hem") %>) изначально поставляется с встроенной поддержкой предварительной компиляции eco шаблонов, предварительная компиляция шаблонов очень проста, если они носят расширение `.eco`. Они оборачиваются в ваше приложение автоматически и доступны в виде функций, что позволяет их использовать через вызов этих функций.
    
    render: ->
      @html require("app/views/contact")(@contact)
      
Как видно в примере выше, мы просто запрашиваем представление, а затем вызываем его непосредственно указывая в аргументах вызова контекст (в данном случае это экземпляр модели).

Вызов представления возвращает отрендеренный шаблон в виде строки, которую мы передаем в функцию `@html()` обновляя элемент `@el` контроллера.

##Ассоциация с данными

Шаблоны eco связываются внутри со строками и по этой причине невозможно ассоциировать html элемент шаблона с каким-либо объектом. Например, нельзя выполнить рендеринг списка записей в шаблонах Eco отслеживая событие клика левой клавишей мыши на нем, и затем ассоциировать события кликов с настоящими записями. Хотя это и достаточно популярная практика в разработке веб приложений.

К счастью Hem имеет решение, в виде `.jeco` шаблонов. Если вы даете шаблонами расширение `.jeco` вместо `.eco`, то они будут обернуты в jQuery селектор, который будет ассоциировать элемент страницы с данными.

    # app/views/contacts.jeco
    <div class="item"><%= @name %></div>
    
    # app/controllers/contacts.coffee
    class Contacts extends Spine.Controller
      events: 'click .item': 'clicked'

      render: ->
        items = Contact.all()
        @html @require('views/contacts')(items)
        
      clicked: (e) ->
        element = $(e.target)
        item = element.data('item')
        @log "Contact #{item.name} was clicked"

Через коллбек `clicked()` мы обращаемся к объекту события `e`, находя `element` с которым событие ассоциировано, а затем находим запись, которая ассоциирована с этим элементом - `item`. Spine предоставляет сокращенный синтаксис для всего это в `spine/lib/tmpl`:

    # app/controllers/contacts.coffee
    require('spine/lib/tmpl')
    class Contacts extends Spine.Controller
      clicked: (e) ->
        item = $(e.target).item()
        @log "Contact #{item.name} was clicked"
        
Утилита `tmpl.coffee` добавляет в ваши объекты функцию `$.fn.item()` из jQuery, которая будет возвращать данные, что ассоциированы с элементами страницы.

`.jeco` также имеют преимущество в том, что вы можете передавать в них массив для рендеринга, а они будут автоматически пробегать по нему и рендерить коллекцию элементов.

##Хелперы шаблонов

Хелперы шаблонов весьма полезны для описания логики представлений без издевательства над MVC и помещением огромных кусков логики в файлы представлений. Хелперы шаблонов должны существовать только как свойства контроллеров. Хелперы могут быть вызваны через передачу экземпляра контроллера в шаблон при его рендеринге.

Для примера, давайте рассмотрим контроллер Currencies из [простого приложения Currency](https://github.com/maccman/spine.mobile.currency). Нам необходимо отформатировать `@output` и `@input` числа, ставя запятую через каждые три цифры для удобства их чтения. Вот идеальный сценарий такого хелпера:

    class Currencies extends Spine.Controller
      render: ->
        @output = @input and (@input * @rate()).toFixed(2) or 0
        @html require('views/currency')(@)
        
        helper:
          format: (num) ->
            num.toString().replace(/\B(?=(?:\d{3})+(?!\d))/g, ",")

Внутри шаблона мы можем вызывать хелпер и передавать в него необходимые переменные:
    
    <section class="input">
      <h1><%%= @helper.format(@input) %></h1>
      <h1><%%= @helper.format(@output) %></h1>
    </section>
    
Просто и чисто!

##Связывание

Связывание данных - это очень мощная техника, которая позволяет убедиться в том, что данные модели синхронизированы с представлением. Эта техника заключается в том, что контроллеры связываются с событиями модели повторно рендеря шаблоны после возникновения соответствующих событий. Давайте возьмем простой пример - список контактов. Контроллер будет привязан к событиям модели *refresh* и *change*, который возникают при каждый раз когда изменяются данные модели. Когда происходит определенное событие, контроллер повторно рендерит представление.

    class ContactsList extends Spine.Controller
      constructor: ->
        Contact.bind('refresh change', @render)
        
      render: =>
        items = Contact.all()
        @html require('views/contacts')(items)
        
Обратите внимание на то, что мы используем 'fat arrow' ( => ) для функции `render()`. Благодаря этому мы убеждены в том, что `render()` вызывается в правильном контексте `ContactsList`, а не `Contact`. Чтобы узнать больше информации о привязке функций обратите внимание на [руководство по классам](<%= docs_path("classes") %>).

Существует несколько типичных паттернов связывания, подробнее о них можно узнать в [руководстве по паттернам контроллеров](<%= docs_path("controller_patterns") %>).
